import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
// NOTE: stocks í…Œì´ë¸” ì‚¬ìš©ìœ¼ë¡œ ì„±ëŠ¥ ê°œì„ 
import { edgeCache, setCacheHeaders, CACHE_KEYS, CACHE_TAGS } from '../../../../lib/edge-cache';

// ë‹¤ì¤‘ ë ˆë²¨ ìºì‹œ ì €ì¥ì†Œ - ì™„ì „ ë¬´íš¨í™” (mention_count ë¡œì§ ìˆ˜ì •)
let stocksCache: {
  data: any[];
  timestamp: number;
  hitCount: number;
  missCount: number;
} | null = null; // ìºì‹œ ì™„ì „ ë¬´íš¨í™”: mention_count ê³„ì‚° ë¡œì§ ìˆ˜ì •ìœ¼ë¡œ ì¸í•œ ìºì‹œ í´ë¦¬ì–´

let priceCache = new Map<string, {
  data: any;
  timestamp: number;
}>();

const CACHE_TTL = 30 * 60 * 1000; // 30ë¶„ìœ¼ë¡œ ë‹¨ì¶• (ì„±ëŠ¥ í–¥ìƒ)
const PRICE_CACHE_TTL = 5 * 60 * 1000; // 5ë¶„ (ì‹¤ì‹œê°„ ê°€ê²©)

// ìºì‹œ ì„±ëŠ¥ ë©”íŠ¸ë¦­
function getCacheMetrics() {
  const total = (stocksCache?.hitCount || 0) + (stocksCache?.missCount || 0);
  const hitRate = total > 0 ? (stocksCache?.hitCount || 0) / total : 0;
  return { hitRate, total, hits: stocksCache?.hitCount || 0, misses: stocksCache?.missCount || 0 };
}

// ìºì‹œëœ ê°€ê²© ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
async function getCachedStockPrice(ticker: string, market: string) {
  const cacheKey = `${ticker}_${market}`;
  const now = Date.now();
  
  // ìºì‹œ í™•ì¸
  if (priceCache.has(cacheKey)) {
    const cached = priceCache.get(cacheKey)!;
    if ((now - cached.timestamp) < PRICE_CACHE_TTL) {
      console.log(`ğŸ’¾ Using cached price for ${ticker}`);
      return cached.data;
    } else {
      priceCache.delete(cacheKey);
    }
  }
  
  // ìºì‹œ ë¯¸ìŠ¤ - ìƒˆë¡œìš´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (íƒ€ì„ì•„ì›ƒ ì¶”ê°€)
  try {
    const priceData = await getStockPrice(ticker, market);
    
    // ì„±ê³µí•œ ê²½ìš°ì—ë§Œ ìºì‹œ ì €ì¥
    if (priceData) {
      priceCache.set(cacheKey, {
        data: priceData,
        timestamp: now
      });
    }
    
    return priceData;
  } catch (error) {
    console.warn(`â±ï¸ Price fetch timeout for ${ticker}`);
    return null; // íƒ€ì„ì•„ì›ƒì‹œ null ë°˜í™˜í•˜ì—¬ ë¹ ë¥¸ ë¡œë”©
  }
}

// ì‹¤ì œ ì£¼ê°€ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ (íƒ€ì„ì•„ì›ƒ ìµœì í™”)
async function getStockPrice(ticker: string, market: string) {
  try {
    // Yahoo Financeì—ì„œ ì‹¤ì œ ê°€ê²© ê°€ì ¸ì˜¤ê¸°
    const isKoreanStock = ticker.length === 6 && !isNaN(Number(ticker));
    const symbol = isKoreanStock ? `${ticker}.KS` : ticker;
    
    console.log(`ğŸ“ˆ Fetching price for ${ticker} (${symbol})...`);
    
    // íƒ€ì„ì•„ì›ƒ ì¶”ê°€ë¡œ ì„±ëŠ¥ ê°œì„ 
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000); // 3ì´ˆ íƒ€ì„ì•„ì›ƒ
    
    const response = await fetch(
      `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${Math.floor(Date.now() / 1000) - 86400}&period2=${Math.floor(Date.now() / 1000)}&interval=1d`,
      {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        },
        signal: controller.signal,
        next: { revalidate: 300 } // 5ë¶„ ìºì‹œ
      }
    );
    
    clearTimeout(timeoutId);

    if (response.ok) {
      const data = await response.json();
      const result = data.chart?.result?.[0];
      
      if (result?.meta) {
        const currentPrice = result.meta.regularMarketPrice;
        const previousClose = result.meta.chartPreviousClose || result.meta.regularMarketPreviousClose;
        const currency = result.meta.currency;
        
        if (currentPrice && previousClose) {
          const changeAmount = currentPrice - previousClose;
          const changePercent = ((changeAmount / previousClose) * 100).toFixed(2);
          const changeSign = changeAmount >= 0 ? '+' : '';
          
          return {
            current: isKoreanStock ? Math.round(currentPrice) : parseFloat(currentPrice.toFixed(2)),
            currency: currency === 'KRW' ? 'KRW' : 'USD',
            change: `${changeSign}${changePercent}%`
          };
        }
      }
    }
    
    // API ì‹¤íŒ¨ ì‹œ null ë°˜í™˜ (ëª¨ì˜ ë°ì´í„° ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
    console.warn(`âš ï¸ Failed to fetch real price for ${ticker}, using null`);
    return null;
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      console.warn(`â±ï¸ Price fetch timeout for ${ticker}`);
    } else {
      console.error(`âŒ Error fetching price for ${ticker}:`, error);
    }
    return null;
  }
}

// ì¢…ëª© ë°ì´í„° ë¡œë“œ í•¨ìˆ˜ (ì§€ëŠ¥í˜• ìºì‹œ ì ìš©)
async function loadStocksData(pricesOnly: string | null = null): Promise<any[]> {
  const now = Date.now();
  
  // ê°€ê²© ì •ë³´ í¬í•¨ ì—¬ë¶€ì— ë”°ë¼ ìºì‹œ ì‚¬ìš©ì„ ê²°ì • (ê°€ê²© ì •ë³´ëŠ” ì‹¤ì‹œê°„ì´ë¯€ë¡œ ìºì‹œ ì‚¬ìš© ì•ˆí•¨)
  const useCache = pricesOnly === 'false'; // ê¸°ë³¸ ì •ë³´ë§Œ ìš”ì²­í•  ë•Œë§Œ ìºì‹œ ì‚¬ìš©
  
  // ìºì‹œê°€ ìœ íš¨í•œ ê²½ìš° ìºì‹œ ë°ì´í„° ë°˜í™˜ (ê°€ê²© ì •ë³´ ì—†ëŠ” ê²½ìš°ë§Œ)
  if (useCache && stocksCache && (now - stocksCache.timestamp) < CACHE_TTL) {
    console.log('ğŸ¯ Cache HIT for merry:picks:basic (0ms)');
    stocksCache.hitCount = (stocksCache.hitCount || 0) + 1;
    
    // ìºì‹œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    const metrics = getCacheMetrics();
    if (metrics.hitRate < 0.8 && metrics.total > 5) {
      console.warn(`ğŸš¨ Performance Alert: cacheHitRate = ${metrics.hitRate.toFixed(1)} (threshold: 0.8)`);
    }
    
    return stocksCache.data;
  }
  
  console.log(`ğŸ’¾ Cache MISS for merry:picks:${pricesOnly === 'false' ? 'basic' : 'withprices'}, fetching...`);
  console.log('ğŸ”„ Loading fresh stocks data from SQLite DB');
  
  // ìºì‹œ ë¯¸ìŠ¤ ì¹´ìš´íŠ¸ ì¦ê°€
  if (stocksCache) {
    stocksCache.missCount = (stocksCache.missCount || 0) + 1;
  }
  
  let stockData = [];
  
  try {
    // PERFORMANCE OPTIMIZED: Use stocks table directly
    console.log('ğŸš€ Using stocks table for optimized stock data');
    
    // stocks í…Œì´ë¸”ì—ì„œ ì§ì ‘ ë°ì´í„° ì¡°íšŒ - ticker ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë³µ ì™„ì „ ì œê±°
    const stocksQuery = `
      SELECT 
        s.ticker,
        -- ê°€ì¥ ì™„ì „í•œ ë°ì´í„°ë¥¼ ì„ íƒ (NULLì´ ì•„ë‹Œ ê°’ ìš°ì„ )
        COALESCE(MAX(CASE WHEN s.company_name IS NOT NULL AND s.company_name != '' THEN s.company_name END), MAX(s.company_name)) as company_name,
        COALESCE(MAX(CASE WHEN s.market IS NOT NULL AND s.market != '' THEN s.market END), MAX(s.market)) as market,
        MAX(s.mention_count) as mention_count,
        MAX(s.last_mentioned_date) as last_mentioned_at,
        MAX(s.first_mentioned_date) as first_mentioned_date,
        MAX(s.last_mentioned_date) as last_mentioned_date,
        COALESCE(MAX(CASE WHEN s.sector IS NOT NULL AND s.sector != '' THEN s.sector END), MAX(s.sector)) as sector,
        COALESCE(MAX(CASE WHEN s.industry IS NOT NULL AND s.industry != '' THEN s.industry END), MAX(s.industry)) as industry,
        COALESCE(MAX(CASE WHEN s.description IS NOT NULL AND s.description != '' THEN s.description END), MAX(s.description)) as description,
        COALESCE(MAX(CASE WHEN s.tags IS NOT NULL AND s.tags != '' AND s.tags != '[]' THEN s.tags END), MAX(s.tags)) as tags,
        -- ì‹¤ì œ ë¶„ì„ ì™„ë£Œëœ ê³ ìœ í•œ post_id ê°œìˆ˜ë§Œ ì¹´ìš´íŠ¸
        COUNT(DISTINCT psa.log_no) as analyzed_count
      FROM stocks s
      LEFT JOIN post_stock_analysis psa ON s.ticker = psa.ticker
      GROUP BY s.ticker
      ORDER BY last_mentioned_date DESC NULLS LAST, mention_count ASC
    `;
    
    const stockResults = await new Promise<any[]>((resolve, reject) => {
      const StockDB = require('../../../../lib/stock-db-sqlite3');
      const stockDB = new StockDB();
      stockDB.connect().then(() => {
        stockDB.db.all(stocksQuery, [], (err: any, rows: any) => {
          stockDB.close();
          if (err) reject(err);
          else resolve(rows || []);
        });
      });
    });
    
    // stocks ë°ì´í„°ë¥¼ ê¸°ì¡´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (mention_count + analyzed_count í¬í•¨)
    stockData = stockResults.map(stock => ({
      ticker: stock.ticker,
      company_name: stock.company_name,
      name: stock.company_name,
      market: stock.market || (stock.ticker.length === 6 ? 'KRX' : 'NASDAQ'),
      sector: stock.sector, // ğŸ¯ ì„¹í„° ì •ë³´ ì¶”ê°€ (í•„í„°ë§ í•„ìˆ˜)
      mention_count: stock.mention_count, // ğŸ¯ stocks í…Œì´ë¸”ì˜ mention_countê°€ ê³§ blog_postsì—ì„œ ì–¸ê¸‰ëœ íšŸìˆ˜
      analyzed_count: stock.analyzed_count, // ğŸ¯ ì‹¤ì œ ê°ì • ë¶„ì„ ì™„ë£Œëœ í¬ìŠ¤íŠ¸ ê°œìˆ˜ (ë©”ë¥´'s Pickì—ì„œ "ë¶„ì„ ì™„ë£Œ" í‘œì‹œìš©)
      last_mentioned_at: stock.last_mentioned_at,
      first_mentioned_date: stock.first_mentioned_date,
      last_mentioned_date: stock.last_mentioned_date,
      sentiment: 'neutral', // ë³„ë„ ê°ì • ë¶„ì„ ì¡°íšŒ í•„ìš”ì‹œ ì¶”ê°€
      tags: stock.tags || null, // stocks í…Œì´ë¸”ì˜ tags ì»¬ëŸ¼ ì‚¬ìš©
      description: stock.description || `${stock.company_name} (${stock.sector || stock.industry || 'íˆ¬ì ì¢…ëª©'})`
    }));
    
    console.log(`âœ… stocks í…Œì´ë¸”ì—ì„œ ${stockData.length}ê°œ ì¢…ëª© ë¡œë“œ ì™„ë£Œ (ì§ì ‘ ë°©ì‹)`);
  } catch (error) {
    console.error('ğŸ’¥ ì¢…ëª© ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨:', error);
    
    // CLAUDE.md ì›ì¹™: Dummy data ì ˆëŒ€ ê¸ˆì§€ - DB ì‹¤íŒ¨ì‹œ ì—ëŸ¬ ì²˜ë¦¬
    throw new Error('ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
  }

  // ğŸš€ ìˆœì°¨ì  ë¡œë”©: pricesOnly íŒŒë¼ë¯¸í„°ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ê°€ê²© ë¡œë”©
  const shouldLoadPrices = pricesOnly === 'true'; // 'true'ì¼ ë•Œë§Œ ê°€ê²© ë¡œë”©, ë‚˜ë¨¸ì§€ëŠ” ìŠ¤í‚µ
  
  if (shouldLoadPrices) {
    console.log('ğŸ”¥ Loading prices in parallel with UX optimization...');
  } else {
    console.log('ğŸ”¥ Skipping price loading for faster initial response...');
    
    // ê°€ê²© ì •ë³´ ì—†ì´ ê¸°ë³¸ ë°ì´í„°ë§Œ ì²˜ë¦¬
    stockData.forEach((stock: any) => {
      // ê°€ê²© ì •ë³´ë¥¼ nullë¡œ ì„¤ì •
      stock.currentPrice = null;
      stock.currency = stock.market === 'KOSPI' || stock.market === 'KOSDAQ' || stock.market === 'KRX' ? 'KRW' : 'USD';
      stock.priceChange = null;
      
      // ê¸°ë³¸ ë°ì´í„° ì •ë¦¬
      stock.name = stock.company_name || stock.name;
      stock.mentions = stock.mention_count;
      stock.lastMention = stock.last_mentioned_at;
      
      // ğŸ”§ tags JSON ë¬¸ìì—´ì„ ë°°ì—´ë¡œ ë³€í™˜
      if (stock.tags && typeof stock.tags === 'string') {
        try {
          stock.tags = JSON.parse(stock.tags);
        } catch (error) {
          console.warn(`Failed to parse tags for ${stock.ticker}:`, error);
          stock.tags = [];
        }
      } else if (!Array.isArray(stock.tags)) {
        stock.tags = [];
      }
    });
  }

  if (shouldLoadPrices) {
    // ğŸ¯ UX ê°œì„ : ë°°ì¹˜ í¬ê¸° ì œí•œìœ¼ë¡œ ì‘ë‹µì„± í–¥ìƒ (10ê°œì”© ì²˜ë¦¬)
    const batchSize = 10;
    const batches = [];
    for (let i = 0; i < stockData.length; i += batchSize) {
      batches.push(stockData.slice(i, i + batchSize));
    }
    
    // ì²« ë²ˆì§¸ ë°°ì¹˜ëŠ” ì¦‰ì‹œ ì²˜ë¦¬, ë‚˜ë¨¸ì§€ëŠ” ë³‘ë ¬ ì²˜ë¦¬
    const pricePromises = stockData.map(async (stock: any, index: number) => {
      try {
        // ğŸš€ ìš°ì„ ìˆœìœ„: ìƒìœ„ 10ê°œëŠ” ë” ë¹ ë¥´ê²Œ ë¡œë”©
        const timeout = index < 10 ? 3000 : 2000; 
        const priceData = await getCachedStockPrice(stock.ticker, stock.market, timeout);
        
        if (priceData) {
          stock.currentPrice = priceData.current;
          stock.currency = priceData.currency;
          stock.priceChange = priceData.change;
        } else {
          // ì‹¤ì œ ê°€ê²©ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ëŠ” ê²½ìš°
          stock.currentPrice = null;
          stock.currency = stock.market === 'KOSPI' || stock.market === 'KOSDAQ' || stock.market === 'KRX' ? 'KRW' : 'USD';
          stock.priceChange = null;
        }
        
        // ë°ì´í„° ì¼ê´€ì„± í™•ë³´
        stock.name = stock.company_name || stock.name;
        stock.mentions = stock.mention_count;
        stock.lastMention = stock.last_mentioned_at;
        
        // ğŸ”§ tags JSON ë¬¸ìì—´ì„ ë°°ì—´ë¡œ ë³€í™˜
        if (stock.tags && typeof stock.tags === 'string') {
          try {
            stock.tags = JSON.parse(stock.tags);
          } catch (error) {
            console.warn(`Failed to parse tags for ${stock.ticker}:`, error);
            stock.tags = [];
          }
        } else if (!Array.isArray(stock.tags)) {
          stock.tags = [];
        }
        
        return stock;
      } catch (error) {
        console.warn(`âš ï¸ Error processing stock ${stock.ticker}:`, error);
        return stock;
      }
    });

    // ëª¨ë“  ê°€ê²© ì •ë³´ë¥¼ ë³‘ë ¬ë¡œ ê°€ì ¸ì˜¤ê¸° (Promise.allSettledë¡œ ì•ˆì •ì„± í™•ë³´)
    const results = await Promise.allSettled(pricePromises);
    stockData = results
      .filter(result => result.status === 'fulfilled')
      .map(result => result.value);
  }

  // ìºì‹œ ì—…ë°ì´íŠ¸ (ê°€ê²© ì •ë³´ ì—†ëŠ” ê¸°ë³¸ ë°ì´í„°ë§Œ ìºì‹œ)
  if (useCache) {
    stocksCache = {
      data: stockData,
      timestamp: now,
      hitCount: stocksCache?.hitCount || 0,
      missCount: (stocksCache?.missCount || 0) + 1
    };
    console.log(`âœ… Cached ${stockData.length} basic stocks data for 30 minutes`);
  } else {
    console.log(`âœ… Returning ${stockData.length} stocks with real-time prices (no cache)`);
  }
  return stockData;
}

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  const performanceMetrics = {
    dbQueryTime: 0,
    priceApiTime: 0,
    totalResponseTime: 0,
    cacheMetrics: null,
    itemsReturned: 0,
    cacheStatus: 'MISS',
    optimizationLevel: 'ULTRA_PERFORMANCE'
  };

  try {
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '10'); // í˜ì´ì§€ë„¤ì´ì…˜: 10ê°œì”© ë¡œë”©
    const page = parseInt(searchParams.get('page') || '1');
    const tag = searchParams.get('tag');
    const market = searchParams.get('market');
    const sector = searchParams.get('sector'); // ìƒˆë¡œìš´ ì„¹í„° í•„í„°
    const sentiment = searchParams.get('sentiment');
    const pricesOnly = searchParams.get('pricesOnly');
    
    // ìƒˆë¡œìš´ í•„í„° íŒŒë¼ë¯¸í„°ë“¤
    const region = searchParams.get('region');
    const majorSector = searchParams.get('majorSector');
    const subSector = searchParams.get('subSector');
    const search = searchParams.get('search');
    
    const offset = (page - 1) * limit;

    // ULTRA PERFORMANCE: Edge cache + optimized DB (ê°€ê²© ì—¬ë¶€ì— ë”°ë¼ ìºì‹œ í‚¤ êµ¬ë¶„)
    const cacheKey = pricesOnly === 'false' 
      ? `${CACHE_KEYS.MERRY_PICKS()}_basic` 
      : `${CACHE_KEYS.MERRY_PICKS()}_withprices`;
    const dbQueryStart = Date.now();
    
    const result = await edgeCache.getOrSet(
      cacheKey,
      () => loadStocksData(pricesOnly),
      {
        ttl: 300, // 5 minutes
        tags: [CACHE_TAGS.STOCKS, CACHE_TAGS.MERRY]
      }
    );
    
    let stockData = result.data;
    performanceMetrics.dbQueryTime = Date.now() - dbQueryStart;
    performanceMetrics.cacheStatus = result.cached ? 'HIT' : 'MISS';

    // ìºì‹œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    (performanceMetrics as any).cacheMetrics = getCacheMetrics();

    // ìµœì‹  ì–¸ê¸‰ì¼ ê¸°ì¤€ ì •ë ¬ (last_mentioned_at DESC, mention_count ASC)
    stockData.sort((a, b) => {
      // ìµœì‹  ì–¸ê¸‰ì¼ ê¸°ì¤€ ë¨¼ì €
      const dateA = new Date(a.last_mentioned_at).getTime();
      const dateB = new Date(b.last_mentioned_at).getTime();
      if (dateA !== dateB) {
        return dateB - dateA; // ìµœì‹  ì–¸ê¸‰ì¼ ë‚´ë¦¼ì°¨ìˆœ
      }
      // ê°™ì€ ë‚ ì§œë©´ ì–¸ê¸‰ ì ì€ ìˆœìœ¼ë¡œ ì •ë ¬
      return a.mention_count - b.mention_count;
    });

    // í•„í„°ë§
    if (tag) {
      stockData = stockData.filter(stock => 
        stock.tags && stock.tags.some((t: any) => t.includes(tag))
      );
    }
    
    if (market && market !== 'all') {
      stockData = stockData.filter(stock => stock.market === market);
    }
    
    // ìƒˆë¡œìš´ ì„¹í„° í•„í„° ì¶”ê°€
    if (sector && sector !== 'all') {
      stockData = stockData.filter(stock => stock.sector === sector);
    }
    
    if (sentiment && sentiment !== 'all') {
      stockData = stockData.filter(stock => stock.sentiment === sentiment);
    }

    // ìƒˆë¡œìš´ í•„í„°ë§ ë¡œì§
    // 1. ì§€ì—­ í•„í„°ë§ (êµ­ë‚´/í•´ì™¸)
    if (region && region !== 'all') {
      const regionMarkets = {
        'êµ­ë‚´': ['KOSPI', 'KOSDAQ', 'KRX'],
        'í•´ì™¸': ['NASDAQ', 'NYSE', 'TSE']
      };
      
      const markets = regionMarkets[region as keyof typeof regionMarkets] || [];
      stockData = stockData.filter(stock => 
        markets.includes(stock.market || 'NASDAQ')
      );
    }
    
    // 2. ëŒ€ë¶„ë¥˜ ì„¹í„° í•„í„°ë§
    if (majorSector && majorSector !== 'all') {
      const sectorCategories = {
        'ê¸°ìˆ /IT': ['ê¸°ìˆ ', 'ë°˜ë„ì²´', 'ì „ììƒê±°ë˜'],
        'ì—ë„ˆì§€/ì›ìë ¥': ['ì—ë„ˆì§€', 'ì›ìë ¥', 'ìš°ë¼ëŠ„'],
        'ì‚°ì—…/ì œì¡°': ['ì² ê°•', 'ì¡°ì„ ', 'ì†Œì¬', 'í™”í•™'],
        'ìš´ì†¡/ëª¨ë¹Œë¦¬í‹°': ['ì „ê¸°ì°¨', 'ìë™ì°¨'],
        'ì†Œë¹„ì¬/ì„œë¹„ìŠ¤': ['ì—”í„°í…Œì¸ë¨¼íŠ¸'],
        'í—¬ìŠ¤ì¼€ì–´': ['ì œì•½', 'í—¬ìŠ¤ì¼€ì–´'],
        'ì‹ ì†Œì¬/ë°°í„°ë¦¬': ['ë°°í„°ë¦¬', 'í¬í† ë¥˜']
      };
      
      const sectors = sectorCategories[majorSector as keyof typeof sectorCategories] || [];
      stockData = stockData.filter(stock => 
        sectors.includes(stock.sector || '')
      );
    }
    
    // 3. ì†Œë¶„ë¥˜ ì„¹í„° í•„í„°ë§
    if (subSector && subSector !== 'all') {
      stockData = stockData.filter(stock => stock.sector === subSector);
    }
    
    // 4. ê²€ìƒ‰ í•„í„°ë§
    if (search) {
      const searchLower = search.toLowerCase();
      stockData = stockData.filter(stock => 
        (stock.name?.toLowerCase().includes(searchLower)) ||
        (stock.company_name?.toLowerCase().includes(searchLower)) ||
        (stock.ticker?.toLowerCase().includes(searchLower))
      );
    }

    // í˜ì´ì§€ë„¤ì´ì…˜ ì ìš©
    const paginatedStocks = stockData.slice(offset, offset + limit);
    performanceMetrics.itemsReturned = paginatedStocks.length;

    // ì´ ì‘ë‹µ ì‹œê°„ ê³„ì‚°
    performanceMetrics.totalResponseTime = Date.now() - startTime;

    // ì„±ëŠ¥ ê²½ê³  (ëª©í‘œ: <500ms)
    if (performanceMetrics.totalResponseTime > 500) {
      console.warn(`âš ï¸ PERFORMANCE WARNING: Response time ${performanceMetrics.totalResponseTime}ms exceeds 500ms target`);
    }

    // ì„±ëŠ¥ ë¡œê·¸ (ê°œë°œ í™˜ê²½ì—ì„œë§Œ)
    console.log(`ğŸ“Š Performance Metrics:`, {
      ...performanceMetrics,
      target: '< 500ms',
      status: performanceMetrics.totalResponseTime < 500 ? 'âœ… GOOD' : 'âŒ SLOW'
    });

    const response = NextResponse.json({
      success: true,
      data: {
        stocks: paginatedStocks,
        total: stockData.length,
        page,
        limit,
        hasMore: offset + limit < stockData.length
      }
    });
    
    // Set optimized cache headers
    return setCacheHeaders(response, {
      ttl: 300, // 5 minutes
      staleWhileRevalidate: 600, // 10 minutes SWR
      tags: [CACHE_TAGS.STOCKS, CACHE_TAGS.MERRY]
    });

  } catch (error) {
    performanceMetrics.totalResponseTime = Date.now() - startTime;
    console.error('ğŸ’¥ ì¢…ëª© ì¡°íšŒ ì˜¤ë¥˜:', error);
    console.error(`ğŸ’¥ Error Response Time: ${performanceMetrics.totalResponseTime}ms`);
    
    const errorResponse = NextResponse.json({
      success: false,
      error: { message: 'ì¢…ëª© ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨', details: error instanceof Error ? error.message : 'Unknown error' }
    }, { status: 500 });
    
    // No cache on errors
    errorResponse.headers.set('Cache-Control', 'no-store');
    return errorResponse;
  }
}